import React, { useState, useEffect } from "react";
import TypeaheadNative from "./TypeaheadNative";
import "fastestsmallesttextencoderdecoder";

// @ts-ignore
const {
  buildOtherSuggestion,
  buildFieldSuggestion,
  buildCustomSearchBox,
  buildCustomStandaloneSearchBox,
} = require("./browser/headless_extension_bundle");
const { buildSearchEngine, buildResultList } = require("@coveo/headless");

const {
  buildProductListingEngine,
  buildProductListing,
  buildPager,
} = require("@coveo/headless/product-listing");

/* OPTIONS: core platform api parameters */
const defaultEngineOptions = {
  configuration: {
    organizationId: "[REPLACE]",
    accessToken: "[REPLACE]",
  },
};
/* OPTIONS: searchbox parameters */
const sbOptions = {
  numberOfSuggestions: 5,
  highlightOptions: {
    exactMatchDelimiters: {
      open: "<mark>",
      close: "</mark>",
    },
  },
};

/* OPTIONS: standalone searchbox parameters */
const standaloneSbOptions = {
  ...sbOptions,
  redirectionUrl: "http://placeholder.com",
};

const SearchNative = (props) => {
  /* Product Suggestion add-on: to be assigned to the searchbox object 
    - This is "Search" approach. See lower the "Field Value" approach 
    - Search approach is searching in the title, description, etc.. .of the idnex record
*/
  const productsuggestion_engine = buildSearchEngine(defaultEngineOptions);

  const [engineState, setEngineState] = useState(
    productsuggestion_engine.state
  );
  useEffect(
    () =>
    productsuggestion_engine.subscribe(() =>
    setEngineState(productsuggestion_engine.state)
      ),
    []
  );

  //productsuggestion_engine.executeFirstSearch();

  const productFilterExpression = '@source=="Product Catalog"';
  const productsuggestion_groupname = "ProductSuggestions";
  const productSuggestions = buildOtherSuggestion(
    productsuggestion_engine,
    productsuggestion_groupname,
    "buildResultList",
    productFilterExpression,
    { options: { fieldsToInclude: ["sfid"] } }
  );

  /* RelatedContent Suggestion add-on: to be assigned to the searchbox object */
  const relatedcontentsuggestion_engine =
    buildSearchEngine(defaultEngineOptions);
  const relatedcontentFilterExpression =
    '@source=="Dev Sunbelt Rentals Content"';
  const relatedcontentsuggestion_groupname = "RelatedContentSuggestions";
  const relatedcontentSuggestions = buildOtherSuggestion(
    relatedcontentsuggestion_engine,
    relatedcontentsuggestion_groupname,
    "buildResultList",
    relatedcontentFilterExpression,
    { options: { fieldsToInclude: ["sfid"] } }
  );

  /* 
  Category Suggestion add-on: to be assigned to the searchbox object 
    - fetches values from jpderytest_category_l3 field - generated by IPE "jpdery_test_categoriesextendedfields" by splitting value of "categories" field from catalog
*/
  const { platformUrl, accessToken, organizationId, searchHub } =
    defaultEngineOptions.configuration;
  const catl2_Suggestions = buildFieldSuggestion(
    "L2Categories",
    platformUrl,
    accessToken,
    organizationId,
    searchHub,
    "categoryl2data",
    null,
    false,
    "::"
  );

  /* Product Suggestion add-on: to be assigned to the searchbox object 
    - This is "Field Value" approach, different than above "Sarch" approach 
    - FielValue approach only saerc on title; uses a "trailing wildcard" matching pattern e.g. use types `dingo t`, component will  effectively search for `dingo t*`
*/
  const productNameSuggestions = buildFieldSuggestion(
    productsuggestion_groupname,
    platformUrl,
    accessToken,
    organizationId,
    searchHub,
    "product_name_suggestions",
    null,
    true,
    "::"
  );

  /* buildCustomStandaloneSearchBox  */
  const engine_for_standalonesearchbox =
    buildSearchEngine(defaultEngineOptions);
  /*
const search_based_addons = [productSuggestions, relatedcontentSuggestions]
const field_based_addons = [catl3_Suggestions]
*/
  const search_based_addons = [relatedcontentSuggestions];
  const field_based_addons = [catl2_Suggestions, productNameSuggestions];
  const myCustomStandaloneSearchBox = buildCustomStandaloneSearchBox(
    engine_for_standalonesearchbox,
    { options: standaloneSbOptions },
    search_based_addons,
    field_based_addons
  );

  function onCustomStandaloneSearchBoxUpdate() {
    const state = myCustomStandaloneSearchBox.state;
    console.dir(state, { depth: 2 });
  }

  /* async function plpMain() {
    let engine, productListingController, pagerController;
    const productListingProps = {
        options: {
            url: 'https://example.org/products/Concrete' //sample value asof 20220222
        }
    };

    const pagerProps = {
        options: {
            numberOfPages: 5 //actually default
        }
    };

    const onEngineStateChange = () => {
        const state = engine.state;
        console.dir(state, { depth: 2 });
    };

    const onProductListingControllerStateChange = () => {
        const state = productListingController.state;
        console.dir(state, { depth: 2 });
    };

    const onPagerStateChange = () => {
        const state = pagerController.state;
        console.dir(state, { depth: 2 });
    };

    engine = buildProductListingEngine(defaultEngineOptions);
    //engine.subscribe(onEngineStateChange);

    productListingController = buildProductListing(engine, productListingProps);

    productListingController.subscribe(onProductListingControllerStateChange);

    pagerController = buildPager(engine, pagerProps);
    pagerController.subscribe(onPagerStateChange);

    productListingController.refresh();

    pagerController.nextPage();
}

plpMain(); */

  function watch(fn) {
    // receives a function that must return a bool
    //returns a Promise
    //Promise will be resolved when fn returns true
    return new Promise((resolve, reject) => {
      try {
        var intervalId = setInterval(() => {
          try {
            if (fn()) {
              clearInterval(intervalId);
              resolve();
            }
          } catch (error) {
            reject(error);
          }
        }, 100);
      } catch (error) {
        reject(error);
      }
    });
  }

  return (
    <>
      <TypeaheadNative
        myCustomStandaloneSearchBox={myCustomStandaloneSearchBox}
        {...props}
      />
    </>
  );

  // export function PlpPage() {
  //     return <Plp />
  // }
};

export default SearchNative;
